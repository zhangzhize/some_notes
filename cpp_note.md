# 第一章 开始
## 概述
### 内容
> **类型，变量，表达式，语句，函数**等的基础内容
### 目标
> 学会**编写，编译及运行**简单程序

### 函数
* 返回类型
* 函数名
* 形参列表
* 函数体（**由左花括号开始，右花括号结束的语句块**）
* return语句结束函数的执行，return一个值时，必须与函数的返回类型相同。main函数返回0表示**程序正常运行**，返回其它数表示**程序异常**，具体什么异常由系统定义。
> 重要概念：类型
>> &emsp;类型是程序设计最基本的概念之一。程序中所处理的数据都保存在变量中，而每个变量都有自己的类型。**V具有类型T**和**V是一个T类型变量**是等价的。
### 编译和运行程序
**windows**系统中，由IDE（Integrated Developed Environment)完成.
**程序源码**存储在若干**源文件**中，源文件的后缀常见的有cc、cxx、cpp、c等
**Linux**系统中的编译过程
1. 预处理，g++ -E *.cpp > *.i
2. 编译，g++ -S *.i > *.s
3. 汇编，g++ -C *.s > *.o
4. 链接，g++ *1.o *2.o *3.o -o **bin**

### 初始输入输出
&emsp;C++并没有定义IO语句，而是使用标准库提供IO机制。**iostream**库包含两个**基础类型**：**istream**和**ostream**，分别表示输入输出流，**一个流就是一个字符序列**，从io设备读出或写入io设备的。
> 术语“流（stream）”即：随着时间的推移，**字符是顺序生成或消耗的**

标准库定义的四个IO**对象**
1. 标准输入cin
2. 标准输出cout
3. 标准错误cerr：通常用来输出警告和错误信息
4. 标准错误clog：通常用来输出程序运行时的一般性信息
> 系统通常将**程序所运行的窗口**与这四个对象关联起来:读取cin时，数据从程序正在运行的窗口读入，想cout、cerr和clog写入数据时，将会写到同一个窗口。

**向流写入数据**
`cout<<"..."<<endl;`
&emsp;&emsp;一个表达式产生一个计算结果，这条表达式中使用了**输出运算符(<<)**。<<运算符接受两个运算对象：左侧得运算对象必须史一个ostream对象，右侧得对象是**要打印的值**，输出运算符的计算结果就是其左侧的运算对象，即写入给定值的ostream对象。
&emsp;&emsp;输出流运算符<<的**顺序是从左往右**，则使用多次<<运算符的语句，第一个运算符的结果成为了第二个运算符的左侧运算对象。
&emsp;&emsp;endl被称为**操纵符（manipulator）**的特殊值。写入endl的效果是**结束当前行，并将与设备关联的缓冲区buffer中的内容刷到设备中**。该操作可以保证到目前为止程序产生的**所有输出都真正写入输出流中，而不是仅停留在内存中等写入流。**除此之外，读cin会刷新cout，同时程序异常停止也会刷新cout
> 在调试时的打印语句应该保证“一直”**刷新流**，以防程序崩溃时输出还留在缓冲区中，**导致关于程序崩溃位置的错误判断**。

### 使用标准库中的名字
&emsp;&emsp;cout和endl这些名字是**定义**在名为std的**命名空间（namespace）**中的，命名空间的使用可以**避免名字定义冲突**，以及**使用库中相同名字导致的冲突**。标准库定义的所有名字都在命名空间std中。命名空间的**副作用**：当使用标准库的一个名字都需要std::来指明。

### 控制流
* while(condition) statment
* for语句：循环头和循环体，循环头包括：一个初始化语句，一个循环条件，一个表达式

可用while不断读取输入
> while(cin>>value)
以istream作为条件时，效果是**检测流的状态**
>> 遇到文件结束符(end-of-file)
>> 遇到无效输入，如：读取的输入不是整数

> 从键盘输入文件结束符
>> windows：Ctrl+Z
>> linux：Ctrl+D

### 再探编译
> 编译只能检查形式上的错误，几种常见的编译器可以检查出的错误是
>> **语法错误（syntax error）**
>> **类型错误（type error)**
>> **声明错误（declaration error）**  

错误常常会具有**传递性**，因此最好按照报告的顺序来逐个修正错误。

### 类简介
&emsp;&emsp;一个类**定义了一个类型，以及与其关联的一组操作**，C++最初的一个设计焦点就是能定义使用上像内置类型一样自然的**类类型(class type)**
使用类之前，需要了解：
>1. 类名是什么?
>2. 它是在哪里定义的？
>3. 它支持什么操作？

一般在头文件定义类（编译器一般不关心头文件名的格式，但有的IDE对此有特定要求）

 每个类**定义了一个新的类型**，类型名就是类名。
 `Sales_item item;`即表达item是一个Sales_item类型的而对象，我们可以执行以下操作：
 * 调用isbn函数从一个Sales_item对象中提取ISBN书号
 * 输入运算符>>和输出运算符<<读写Sales_item类型的对象
 * 使用赋值运算符将一个Sales_item对象的值赋给另一个Sales_item对象。
 * 使用加法运算符，复合赋值运算符...
 > 关键概念：类定义了行为
 > > &emsp;&emsp;类的作者定义了**类对象可执行的所有动作**，即：创建时发生什么、赋值时发生什么、加法或输入输出运算符时会发生什么。

 **使用文件名重定向**
 >当测试程序时，反复从键盘输入是比较低效的。可以使用文件重定向机制将标准输入和标准输出与命名文件关联起来：`$addItems <infile >outfile`
 >addItems是可执行文件

# PART2
## 内容
> 第2章 变量和基本类型  
> 第3章 字符串、向量和数组  
> 第4章 表达式  
> 第5章 语句  
> 第6章 函数  
> 第7章 类

* 学习编程语言，**理解语法特征的实现细节是第一步**
* C++扩充基本特征的方式：**自定义数据类型**+**标准库**
* C++是**静态数据类型语言**，类型检查发生在编译时。

### 第2章 变量和基本类型
> 1.基本内置类型
> 2.变量
> 3.复合类型
> 4.const限定符
> 5.处理类型
> 6.自定义数据结构

* 算术类型
    * 整型（包括字符和布尔型）
    * 浮点型
* 空类型（仅用于一些特殊的场合）
> 数据类型决定了程序中数据和操作的意义。
> 数据类型决定了所占的比特数和如何解释这些比特的内容
选择类型的一些经验准则
* 数值不可能为负时，选用无符号类型
* 使用int执行整数运算
* 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们
* 执行浮点数运算选用double

```cpp
bool b=33;
int i=b;
i=3.14;
double pi=i;
unsigned char c=-1;
signed char c2=256;
```
类型所能表示的**值和范围**决定了转换的过程
* 当把一个非布尔类型的算数值赋给布尔类型时，初始值为0则结果为false，否则结果为true
* 当把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1
* 当把一个浮点数赋给整数时，进行了近似处理，结果值仅保留浮点数中小数点之前的部分。
* 当把一个整数赋给浮点类型时，小数部分记为0.如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。
* 当赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总书取模后的余数。
* **当赋给有符号类型一个超出它表示范围的值时，结果是未定义的**。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。
    * 原因在于内存读取机制。在内存中，带符号类型首位是符号位，表示正负。假设此类型占8比特，当读取超出范围的值时，将只读取该数的最后8位进行读取，此时首位数字并不能代表正负，这样的读取没有意义，结果自然就是未定义的。
* 当程序使用了算术类型的值而其实**所需的是另一种类型的值**时，编译器同样会执行上述的类型转换，如`int i=42; if(i) ...`,自动将整型i的值转换为bool值
* 由上一条可知，如果bool类型出现在算术表达式，则会自动转换为0或1。

>**建议**：避免无法预知和依赖于实现环境的行为
&emsp;&emsp;无法阈值的行为源于**编译器无须（有时是不能）检测的错误**。即使代码编译通过了，如果程序执行了一条未定义的表达式，仍有可能产生错误。
&emsp;&emsp;有些情况和/或某些编译器下，含有无法预知行为的程序也能正确执行，但无法保证同样一个程序在别的编译器下能正常工作，甚至已经编译通过的代码再次执行也可能出错。此外，程序对一组输入有效，但对另一组输入不一定有效。
&emsp;&emsp;程序应尽量避免依赖于实现环境的行为。如果把int的尺寸看作是不变的已知值，那么这样的程序是不可移植的。

**含有无符号类型的表达式**
* 算术表达式中既有无符号数又有int值时，int值会转换成无符号数，转换过程和把int直接赋给无符号变量一样（可以看为该复数的补码在无符号类型的表现）。c＝a/b;  d＝a-c×b；求模，c往负无穷方向取，求余，c往0方向取
```cpp
unsigned u=10;
int i=-42;
cout<<i+i<<endl;   //输出-84
cout<<u+i<<endl;   //输出4294967264
i=-3;
cout<<u+i<<endl;   //输出7

unsigned short u1=10;
short i1=-42;
cout<<i1+i1<<endl; //输出-84
cout<<u1+i1<<endl; //输出-32
```
* 当从无符号数中减去一个值时，不管这个值是不是无符号数，**都必须确保结果不能是一个负值
```cpp
unsigned u1=42,u2=10;
cout<<u1-u2<<endl;  //正确：输出32
cout<<u2-u1<<endl;  //正确：不过结果是取模后的值，是未定义的行为
```
* 在循环中使用无符号数有可能会导致死循环
```cpp
for(unsigned u=10;u>0;--u) 
    cout<<u<<endl;
```
解决办法之一是使用while循环（麻烦，不考虑）
```cpp
unsigned u=11;
while(u>0)
{
    --u;
    cout<<u<<endl;
}
```
**提示**：切勿昏庸带符号类型和无符号类型！！！

#### 字面值常量
字面值常量的**形式和值**决定了它的数据类型
**整形字面值**
* 十进制字面值默认是带符号数，类型是int、long、long long中能容纳下当前值且尺寸最小的那个
* 八进制(以0开头的整数)和十六进制(以0x或0X开头的整数)，类型是int、unsigned int、long、unsigned long、long long、unsigned long long中能容纳当前值且尺寸最小的那个。
* 如果一个字面值与之关联的最大的数据类型都放不下，则产生错误
* 尽管整形字面值可以存储在带符号数据类型中，但十进制字面值不会是负数，只是前面的符号取反了而已。
* 以不同的后缀代表相应的字面值类型。

**浮点数字面值**
* 浮点数字面值表现为一个小数或以科学计数法表示的指数，指数部分用E或e标识
* 以不同的后缀代表相应的字面值类型

**字符和字符串字面值**
* 由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值
* 字符串字面值的类型实际上是由常量字符构成的**数组（array）**，编译器会在每个字符串的结尾处添加一个空字符'\0'，因此字符串自卖年至的实际长度要比它的内容多1.
* 字符串字面值可以分行书写
```cpp
cout<<"a really,really long string literal "
      "that spans two lines"<<endl;
```

**转义序列**
* 两类字符：不可打印（如退格）字符和在C++中有特殊含义的字符，需要用到转移序列。
* 泛化转义序列

**指定字面值的类型**
* 整形和浮点型使用相应的后缀，而字符和字符串型则使用前缀

**布尔字面值和指针字面值**
* true和false是布尔类型的字面值
* nullptr是指针字面值
